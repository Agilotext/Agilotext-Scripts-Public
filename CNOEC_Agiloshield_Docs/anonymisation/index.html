<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Anonymisation - Agiloshield</title>
</head>
<body>

<!--
  Agiloshield Embed - Anonymisation (fichiers + texte, mode manuel/Memberstack, tags par type)
  APIs: getToken, anonOfficeText, anonText, cleanupOldJobs, getVersion
-->
<style>
  :root {
    --agilo-primary: var(--color--blue, #174a96);
    --agilo-primary-soft: color-mix(in srgb, var(--color--blue, #174a96) 12%, transparent);
    --agilo-text: var(--color--gris_foncé, #020202);
    --agilo-text-secondary: var(--color--gris, #525252);
    --agilo-surface: var(--color--white, #ffffff);
    --agilo-surface-2: var(--color--blanc_gris, #f8f9fa);
    --agilo-border: rgba(52, 58, 64, 0.12);
    --agilo-success: var(--color--vert, #1c661a);
    --agilo-error: var(--color--rouge, #a82633);

    --space-1: 8px;
    --space-2: 16px;
    --space-3: 24px;
    --space-4: 32px;
    --radius: 16px;
    --ring: color-mix(in srgb, var(--agilo-primary) 28%, transparent);
    --shadow-soft: 0 8px 28px rgba(23, 74, 150, 0.1);
  }

  form[ms-code-anonymisation="form"] {
    max-width: 1160px;
    margin: 0 auto;
    width: 100%;
    color: var(--agilo-text);
    font-family: "Inter", "SF Pro Text", "Segoe UI", sans-serif;
    box-sizing: border-box;
  }
  form[ms-code-anonymisation="form"] *,
  form[ms-code-anonymisation="form"] *::before,
  form[ms-code-anonymisation="form"] *::after {
    box-sizing: border-box;
  }
  form[ms-code-anonymisation="form"] h1,
  form[ms-code-anonymisation="form"] h2,
  form[ms-code-anonymisation="form"] h3,
  form[ms-code-anonymisation="form"] h4,
  form[ms-code-anonymisation="form"] h5,
  form[ms-code-anonymisation="form"] p { margin: 0; }

  .agf-shell {
    background: var(--agilo-surface);
    border-radius: var(--radius);
    box-shadow: var(--shadow-soft);
    padding: var(--space-4);
    display: grid;
    gap: var(--space-2);
  }

  .agf-head {
    display: grid;
    gap: var(--space-1);
    padding: 0;
  }
  .agf-head h2 { font-size: 1.35rem; line-height: 1.25; font-weight: 600; letter-spacing: -0.01em; }
  .agf-head p { color: var(--agilo-text-secondary); font-size: 0.9375rem; }

  .agf-tabs {
    display: grid;
    grid-template-columns: repeat(3, minmax(0, 1fr));
    gap: var(--space-1);
  }
  .agf-tab {
    border: 1px solid var(--agilo-border);
    border-radius: 12px;
    background: var(--agilo-surface-2);
    color: var(--agilo-text-secondary);
    padding: var(--space-2);
    text-align: left;
    cursor: pointer;
    display: grid;
    gap: var(--space-1);
    transition: border-color 150ms ease, box-shadow 150ms ease;
  }
  .agf-tab strong { font-size: 1rem; font-weight: 600; color: var(--agilo-text); }
  .agf-tab span { font-size: 0.8125rem; color: var(--agilo-text-secondary); }
  .agf-tab[aria-selected="true"] {
    background: var(--agilo-surface);
    border-color: var(--agilo-primary);
    box-shadow: 0 0 0 2px color-mix(in srgb, var(--agilo-primary) 18%, transparent);
  }

  .agf-grid {
    display: grid;
    grid-template-columns: minmax(0, 1fr) 280px;
    gap: var(--space-2);
  }

  .agf-main,
  .agf-side {
    border-radius: var(--radius);
    background: var(--agilo-surface-2);
    padding: var(--space-3);
  }
  .agf-main { min-height: 560px; }
  .agf-side { display: grid; gap: var(--space-3); align-content: start; }

  .agf-panel { display: none; gap: var(--space-2); }
  .agf-panel[aria-hidden="false"] { display: grid; }

  .agf-section-title { font-size: 1rem; font-weight: 600; margin-bottom: var(--space-1); }

  .agf-dropzone {
    border: 1.5px dashed var(--agilo-border);
    border-radius: 12px;
    background: var(--agilo-surface-2);
    padding: var(--space-3) var(--space-2);
    text-align: center;
    cursor: pointer;
    transition: border-color 150ms ease, box-shadow 150ms ease;
    outline: none;
  }
  .agf-dropzone:hover,
  .agf-dropzone:focus-visible,
  .agf-dropzone.is-dragover {
    border-color: var(--agilo-primary);
    box-shadow: 0 0 0 4px var(--ring);
  }
  .agf-dropzone h4 { font-size: 1rem; font-weight: 600; }
  .agf-dropzone p { margin-top: var(--space-1); font-size: 0.8125rem; color: var(--agilo-text-secondary); }
  .agf-dropzone .agf-formats-explicit { margin-top: var(--space-1); font-size: 0.75rem; color: var(--agilo-text-secondary); opacity: 0.9; }
  #agfApiLink { color: var(--agilo-text-secondary); text-decoration: none; font-size: 0.75rem; }
  #agfApiLink:hover { text-decoration: underline; color: var(--agilo-primary); }

  #agfFileInput { display: none; }

  .agf-list {
    border: 1px solid var(--agilo-border);
    border-radius: 12px;
    background: var(--agilo-surface);
    min-height: 220px;
    padding: var(--space-2);
    display: grid;
    gap: var(--space-1);
    align-content: start;
  }
  .agf-empty { margin: auto; text-align: center; color: var(--agilo-text-secondary); font-size: 0.875rem; }

  .agf-file {
    border: 1px solid var(--agilo-border);
    border-radius: 10px;
    background: var(--agilo-surface);
    padding: var(--space-1) var(--space-2);
    display: grid;
    grid-template-columns: minmax(0, 1fr) auto;
    align-items: center;
    gap: var(--space-2);
  }
  .agf-file-name { font-size: 0.9375rem; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .agf-file-meta { margin-top: 2px; color: var(--agilo-text-secondary); font-size: 0.8125rem; }
  .agf-remove {
    border: none;
    border-radius: 8px;
    background: transparent;
    color: var(--agilo-text-secondary);
    font-size: 0.8125rem;
    font-weight: 500;
    padding: 6px 12px;
    cursor: pointer;
  }
  .agf-remove:hover { color: var(--agilo-error); }

  .agf-row,
  .agf-cols { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: var(--space-2); }

  .agf-textbox {
    border: 1px solid var(--agilo-border);
    border-radius: 12px;
    background: var(--agilo-surface);
    padding: var(--space-2);
    display: grid;
    gap: var(--space-1);
    min-height: 340px;
  }
  .agf-textbox label { font-size: 0.875rem; font-weight: 600; }
  .agf-textarea {
    width: 100%; min-height: 280px; border: 1px solid var(--agilo-border); border-radius: 10px;
    padding: var(--space-2); font-size: 0.9375rem; line-height: 1.5; resize: vertical; background: var(--agilo-surface);
    color: var(--agilo-text);
  }
  .agf-row--text { min-height: 340px; }
  .agf-textbox--flex { display: flex; flex-direction: column; gap: var(--space-1); min-height: 0; }
  .agf-textbox-head { display: flex; justify-content: space-between; align-items: flex-start; gap: var(--space-2); }
  .agf-textbox-body { flex: 1; overflow: hidden; display: flex; min-height: 0; }
  .agf-textbox-body .agf-textarea { min-height: 260px; flex: 1; }
  .agf-textbox-label { font-size: 0.875rem; font-weight: 600; margin-bottom: var(--space-1); }
  .agf-btn-link--small { font-size: 0.75rem; padding: 0; min-height: auto; }
  .agf-icon-trash, .agf-icon-copy { display: inline-block; width: 14px; height: 14px; vertical-align: -2px; margin-right: 4px; }
  .agf-icon-trash { background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='14' height='14' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6'/%3E%3Cpath d='M3 6h18'/%3E%3Cpath d='M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2'/%3E%3C/svg%3E") no-repeat center; }
  .agf-icon-copy { background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='14' height='14' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Crect width='14' height='14' x='8' y='8' rx='2' ry='2'/%3E%3Cpath d='M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2'/%3E%3C/svg%3E") no-repeat center; }
  .agf-output-wrap {
    flex: 1; min-height: 260px; border-radius: 12px;
    border: 1px solid color-mix(in srgb, var(--agilo-primary) 28%, transparent);
    background: color-mix(in srgb, var(--agilo-primary) 5%, var(--agilo-surface));
    padding: var(--space-2); padding-top: 36px; position: relative; overflow-y: auto;
  }
  .agf-output-copy {
    position: absolute; top: 10px; right: 12px; z-index: 10;
    height: 28px; padding: 0 10px; font-size: 0.75rem; font-weight: 500;
    border-radius: 6px; border: none; background: var(--agilo-primary); color: var(--agilo-surface);
    cursor: pointer; display: inline-flex; align-items: center; gap: 6px;
  }
  .agf-output-copy:hover { background: color-mix(in srgb, var(--agilo-primary) 88%, var(--agilo-text-secondary)); }
  .agf-text-output {
    font-size: 0.875rem; line-height: 1.6; color: var(--agilo-text); white-space: pre-wrap; word-break: break-word;
  }
  .agf-text-output.agf-text-output--loading { opacity: 0.85; }
  .agf-output-stats {
    margin-top: var(--space-2);
    border-top: 1px solid color-mix(in srgb, var(--agilo-primary) 20%, transparent);
    padding-top: 10px;
    display: grid;
    gap: 8px;
  }
  .agf-output-summary { font-size: 0.75rem; color: var(--agilo-text-secondary); }
  .agf-output-entities { display: flex; flex-wrap: wrap; gap: 6px; }
  .agf-output-entity-chip {
    border-radius: 999px;
    border: 1px solid color-mix(in srgb, var(--agilo-primary) 28%, transparent);
    background: color-mix(in srgb, var(--agilo-primary) 8%, var(--agilo-surface));
    color: var(--agilo-text);
    font-size: 0.75rem;
    line-height: 1;
    padding: 5px 8px;
  }
  .agf-tag {
    border-radius: 5px;
    padding: 2px 6px;
    font-size: 0.8125rem;
    font-weight: 600;
    border: 1px solid color-mix(in srgb, var(--agilo-primary) 26%, transparent);
  }
  .agf-tag-PR { background: #fef9c3; color: #422006; }
  .agf-tag-ADR { background: #dbeafe; color: #1e3a8a; }
  .agf-tag-POST { background: #d1fae5; color: #065f46; }
  .agf-tag-LOC { background: #e9d5ff; color: #5b21b6; }
  .agf-tag-MAIL { background: #ffedd5; color: #9a3412; }
  .agf-tag-PHON { background: #ccfbf1; color: #0f766e; }
  .agf-tag-SIREN, .agf-tag-SIRET { background: #fce7f3; color: #831843; }
  .agf-tag-OTHER { background: #f3f4f6; color: #374151; }

  .agf-lock-block {
    border: 1.5px dashed var(--agilo-border);
    border-radius: 12px;
    background: var(--agilo-surface-2);
    min-height: 380px;
    display: grid;
    place-items: center;
    gap: var(--space-2);
    text-align: center;
    padding: var(--space-3);
  }
  .agf-lock-icon { width: 64px; height: 64px; color: var(--agilo-primary); }
  .agf-lock-title { font-size: 1rem; font-weight: 600; }
  .agf-lock-text { color: var(--agilo-text-secondary); font-size: 0.875rem; max-width: 480px; }

  .agf-status {
    display: none; align-items: center; gap: var(--space-1); border-radius: 10px;
    padding: var(--space-2); font-size: 0.9375rem;
  }
  .agf-status.is-visible { display: inline-flex; }
  .agf-status[data-kind="loading"] { color: var(--agilo-primary); background: var(--agilo-primary-soft); }
  .agf-status[data-kind="success"] { color: var(--agilo-success); background: color-mix(in srgb, var(--agilo-success) 10%, transparent); }
  .agf-status[data-kind="error"] { color: var(--agilo-error); background: color-mix(in srgb, var(--agilo-error) 10%, transparent); }
  .agf-spinner { width: 16px; height: 16px; border: 2px solid currentColor; border-right-color: transparent; border-radius: 50%; animation: agf-spin .7s linear infinite; }
  @keyframes agf-spin { to { transform: rotate(360deg); } }

  .agf-actions { display: flex; gap: var(--space-2); flex-wrap: wrap; align-items: center; }
  .agf-btn-primary,
  .agf-btn-secondary,
  .agf-btn-link { min-height: 44px; border-radius: 10px; font-size: 0.9375rem; font-weight: 600; padding: 0 24px; cursor: pointer; transition: background-color 160ms ease, color 160ms ease, border-color 160ms ease, box-shadow 160ms ease; }
  .agf-btn-primary { border: none; background: var(--agilo-primary); color: var(--agilo-surface); }
  .agf-btn-primary:hover:not(:disabled) { background: color-mix(in srgb, var(--agilo-primary) 90%, var(--agilo-text-secondary)); }
  .agf-btn-primary:disabled { opacity: .5; cursor: not-allowed; }
  .agf-btn-primary:focus-visible,
  .agf-btn-secondary:focus-visible,
  .agf-btn-link:focus-visible {
    outline: none;
    box-shadow: 0 0 0 3px color-mix(in srgb, var(--agilo-primary) 28%, transparent);
  }
  .agf-btn-secondary { border: none; background: transparent; color: var(--agilo-text-secondary); text-decoration: underline; text-underline-offset: 2px; }
  .agf-btn-secondary:hover { color: var(--agilo-primary); }
  .agf-btn-link { border: none; background: transparent; color: var(--agilo-text-secondary); text-decoration: underline; text-underline-offset: 2px; }
  .agf-btn-link:hover { color: var(--agilo-primary); }

  .agf-download { display: none; color: var(--agilo-primary); text-decoration: underline; text-underline-offset: 2px; font-size: 0.9375rem; font-weight: 500; padding: 0; }
  .agf-download.is-visible { display: inline-flex; }

  .agf-label { font-size: 0.75rem; text-transform: uppercase; letter-spacing: .04em; color: var(--agilo-text-secondary); }
  .agf-group { display: grid; gap: var(--space-1); }
  .agf-radio-line,
  .agf-item-btn {
    border: 1px solid var(--agilo-border);
    border-radius: 10px;
    background: var(--agilo-surface);
    min-height: 44px;
    padding: var(--space-1) var(--space-2);
    display: flex;
    align-items: center;
    gap: var(--space-1);
    font-size: 0.875rem;
  }
  .agf-radio-line input[type="radio"] { accent-color: var(--agilo-primary); }
  .agf-radio-line:focus-within {
    border-color: color-mix(in srgb, var(--agilo-primary) 40%, transparent);
    box-shadow: 0 0 0 3px color-mix(in srgb, var(--agilo-primary) 18%, transparent);
  }
  .agf-item-btn { width: 100%; justify-content: space-between; cursor: pointer; color: var(--agilo-text); }
  .agf-item-btn:hover { border-color: color-mix(in srgb, var(--agilo-primary) 32%, transparent); }
  .agf-item-btn:focus-visible {
    outline: none;
    border-color: color-mix(in srgb, var(--agilo-primary) 38%, transparent);
    box-shadow: 0 0 0 3px color-mix(in srgb, var(--agilo-primary) 18%, transparent);
  }
  .agf-item-btn.is-active { border-color: color-mix(in srgb, var(--agilo-primary) 40%, transparent); background: color-mix(in srgb, var(--agilo-primary) 7%, var(--agilo-surface)); }
  .agf-chip {
    font-size: 0.6875rem; border: 1px solid var(--agilo-border); border-radius: 999px;
    padding: 2px 8px; color: var(--agilo-text-secondary); background: var(--agilo-surface-2);
  }
  .agf-item-btn--count { position: relative; padding-right: 48px; }
  .agf-chip-count {
    position: absolute;
    top: -8px;
    right: -8px;
    min-width: 22px;
    height: 22px;
    border-radius: 999px;
    background: var(--agilo-primary);
    color: var(--agilo-surface);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 0.6875rem;
    font-weight: 700;
    border: 2px solid var(--agilo-surface);
  }

  .agf-small { font-size: 0.8125rem; color: var(--agilo-text-secondary); }

  .agf-modal-overlay {
    position: fixed; inset: 0; display: none; align-items: center; justify-content: center;
    background: rgba(23, 74, 150, 0.2); z-index: 9999; padding: var(--space-2);
    backdrop-filter: blur(2px);
  }
  .agf-modal-overlay.is-open { display: flex; }
  .agf-modal {
    width: min(560px, 100%); max-height: min(85vh, 680px); overflow: auto;
    background: var(--agilo-surface); border-radius: var(--radius);
    box-shadow: 0 22px 48px rgba(23, 74, 150, 0.2);
    padding: clamp(20px, 3vw, 30px);
    display: grid;
    gap: 18px;
  }
  #agfModalTypesWrap .agf-modal { width: min(980px, 100%); max-height: min(88vh, 760px); }
  .agf-modal-head { display: flex; justify-content: space-between; align-items: start; gap: 14px; }
  .agf-modal-title { font-size: 1.375rem; font-weight: 600; line-height: 1.2; letter-spacing: -0.01em; }
  .agf-modal-subtitle { margin-top: 6px; font-size: 0.875rem; line-height: 1.45; color: var(--agilo-text-secondary); max-width: 72ch; }
  .agf-close {
    border: 1px solid transparent;
    background: transparent;
    font-size: 1.5rem;
    line-height: 1;
    color: var(--agilo-text-secondary);
    cursor: pointer;
    padding: 2px 8px;
    border-radius: 8px;
    transition: background-color 160ms ease, color 160ms ease, border-color 160ms ease, box-shadow 160ms ease;
  }
  .agf-close:hover { color: var(--agilo-text); }
  .agf-close:focus-visible {
    outline: none;
    border-color: color-mix(in srgb, var(--agilo-primary) 38%, transparent);
    box-shadow: 0 0 0 3px color-mix(in srgb, var(--agilo-primary) 18%, transparent);
  }

  .agf-type-grid { display: grid; gap: 14px; }
  .agf-type-card {
    border: 1px solid var(--agilo-border);
    border-radius: 14px;
    padding: 14px;
    display: grid;
    gap: 12px;
    background: var(--agilo-surface);
  }
  .agf-type-card-head {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: var(--space-1);
  }
  .agf-type-card h5 {
    font-size: 0.8125rem;
    text-transform: uppercase;
    letter-spacing: .04em;
    color: var(--agilo-text-secondary);
  }
  .agf-type-card-count {
    border-radius: 999px;
    font-size: 0.6875rem;
    border: 1px solid var(--agilo-border);
    padding: 2px 8px;
    color: var(--agilo-text-secondary);
    background: var(--agilo-surface-2);
  }
  .agf-checkboxes { display: grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap: 12px; }
  .agf-entity-option {
    border: 1px solid var(--agilo-border);
    border-radius: 10px;
    min-height: 44px;
    padding: 10px;
    font-size: 0.875rem;
    display: flex;
    gap: 8px;
    align-items: center;
    background: var(--agilo-surface);
    cursor: pointer;
    transition: border-color 160ms ease, box-shadow 160ms ease, background-color 160ms ease;
  }
  .agf-entity-option:hover { border-color: color-mix(in srgb, var(--agilo-primary) 30%, transparent); }
  .agf-entity-option:focus-within {
    border-color: color-mix(in srgb, var(--agilo-primary) 40%, transparent);
    box-shadow: 0 0 0 3px color-mix(in srgb, var(--agilo-primary) 16%, transparent);
  }
  .agf-entity-option input { accent-color: var(--agilo-primary); margin: 0; }
  .agf-entity-option input:checked + .agf-entity-code {
    background: color-mix(in srgb, var(--agilo-primary) 16%, var(--agilo-surface));
    border-color: color-mix(in srgb, var(--agilo-primary) 42%, transparent);
  }
  .agf-entity-code {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    border-radius: 999px;
    border: 1px solid color-mix(in srgb, var(--agilo-primary) 30%, transparent);
    background: color-mix(in srgb, var(--agilo-primary) 8%, var(--agilo-surface));
    color: color-mix(in srgb, var(--agilo-primary) 80%, var(--agilo-text));
    font-size: 0.6875rem;
    font-weight: 700;
    line-height: 1;
    padding: 4px 8px;
    min-width: 38px;
  }
  .agf-entity-name { color: var(--agilo-text); }
  .agf-entity-option.is-future .agf-entity-name { color: var(--agilo-text-secondary); }
  .agf-entity-option.is-future .agf-entity-code { border-style: dashed; }

  .agf-modal-actions {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: var(--space-2);
    flex-wrap: wrap;
    border-top: 1px solid color-mix(in srgb, var(--agilo-border) 80%, transparent);
    padding-top: 14px;
  }
  .agf-textbox--compact { min-height: auto; }
  .agf-textarea--modal { min-height: 200px; }
  .agf-actions--end { justify-content: flex-end; }
  .agf-modal--wide { width: min(900px, 100%); max-height: min(88vh, 760px); }
  .agf-pseudo-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 18px; }
  .agf-pseudo-card {
    border: 1px solid var(--agilo-border);
    border-radius: 14px;
    background: var(--agilo-surface);
    padding: 14px;
    display: grid;
    gap: 12px;
  }
  .agf-pseudo-title { font-size: 0.875rem; font-weight: 600; color: var(--agilo-text); }
  .agf-pseudo-desc { font-size: 0.75rem; color: var(--agilo-text-secondary); }
  .agf-option-line {
    border: 1px solid var(--agilo-border);
    border-radius: 10px;
    min-height: 42px;
    padding: 8px 10px;
    display: flex;
    align-items: center;
    gap: 8px;
    background: var(--agilo-surface);
    transition: border-color 160ms ease, box-shadow 160ms ease, background-color 160ms ease;
  }
  .agf-option-line:hover { border-color: color-mix(in srgb, var(--agilo-primary) 28%, transparent); }
  .agf-option-line:focus-within {
    border-color: color-mix(in srgb, var(--agilo-primary) 38%, transparent);
    box-shadow: 0 0 0 3px color-mix(in srgb, var(--agilo-primary) 16%, transparent);
  }
  .agf-option-line input[type="radio"],
  .agf-option-line input[type="checkbox"] { accent-color: var(--agilo-primary); }
  .agf-option-line label { font-size: 0.8125rem; font-weight: 500; cursor: pointer; }
  .agf-select-line {
    display: grid;
    gap: 4px;
  }
  .agf-select-line label { font-size: 0.75rem; color: var(--agilo-text-secondary); }
  .agf-select-line select {
    min-height: 38px;
    border: 1px solid var(--agilo-border);
    border-radius: 8px;
    background: var(--agilo-surface);
    color: var(--agilo-text);
    padding: 0 10px;
    transition: border-color 160ms ease, box-shadow 160ms ease;
  }
  .agf-select-line select:focus-visible {
    outline: none;
    border-color: color-mix(in srgb, var(--agilo-primary) 38%, transparent);
    box-shadow: 0 0 0 3px color-mix(in srgb, var(--agilo-primary) 16%, transparent);
  }
  .agf-inc-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 18px; }
  .agf-inc-card {
    border: 1px solid var(--agilo-border);
    border-radius: 14px;
    padding: 14px;
    background: var(--agilo-surface);
    display: grid;
    gap: 12px;
  }
  .agf-inc-card h4 { font-size: 0.9375rem; font-weight: 600; }
  .agf-inc-card p { font-size: 0.75rem; color: var(--agilo-text-secondary); }
  .agf-inc-card--include h4 { color: color-mix(in srgb, var(--agilo-success) 80%, var(--agilo-text)); }
  .agf-inc-card--exclude h4 { color: color-mix(in srgb, var(--agilo-error) 80%, var(--agilo-text)); }
  .agf-inc-add { display: flex; gap: 8px; align-items: center; }
  .agf-inc-add input {
    flex: 1;
    min-height: 36px;
    border: 1px solid var(--agilo-border);
    border-radius: 8px;
    background: var(--agilo-surface);
    color: var(--agilo-text);
    padding: 0 10px;
    font-size: 0.8125rem;
    transition: border-color 160ms ease, box-shadow 160ms ease;
  }
  .agf-inc-add input:focus-visible {
    outline: none;
    border-color: color-mix(in srgb, var(--agilo-primary) 40%, transparent);
    box-shadow: 0 0 0 3px color-mix(in srgb, var(--agilo-primary) 16%, transparent);
  }
  .agf-inc-add button {
    min-height: 36px;
    border-radius: 8px;
    border: 1px solid var(--agilo-border);
    background: var(--agilo-surface);
    color: var(--agilo-text);
    padding: 0 12px;
    font-size: 0.8125rem;
    font-weight: 600;
    cursor: pointer;
    transition: border-color 160ms ease, color 160ms ease, box-shadow 160ms ease, background-color 160ms ease;
  }
  .agf-inc-add button:hover { border-color: color-mix(in srgb, var(--agilo-primary) 45%, transparent); color: var(--agilo-primary); }
  .agf-inc-add button:focus-visible {
    outline: none;
    border-color: color-mix(in srgb, var(--agilo-primary) 40%, transparent);
    box-shadow: 0 0 0 3px color-mix(in srgb, var(--agilo-primary) 16%, transparent);
  }
  .agf-term-list {
    border: 1px solid var(--agilo-border);
    border-radius: 10px;
    background: var(--agilo-surface-2);
    min-height: 120px;
    max-height: 220px;
    overflow-y: auto;
    padding: 8px;
    display: grid;
    gap: 6px;
    align-content: start;
  }
  .agf-term-empty { font-size: 0.75rem; color: var(--agilo-text-secondary); text-align: center; padding: 10px 0; }
  .agf-term-item {
    border: 1px solid var(--agilo-border);
    border-radius: 8px;
    background: var(--agilo-surface);
    padding: 6px 8px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
  }
  .agf-term-item span { font-size: 0.8125rem; color: var(--agilo-text); word-break: break-word; }
  .agf-term-remove {
    border: none;
    background: transparent;
    color: var(--agilo-text-secondary);
    font-size: 0.75rem;
    cursor: pointer;
    padding: 0;
  }
  .agf-term-remove:hover { color: var(--agilo-error); }
  .agf-term-remove:focus-visible {
    outline: none;
    color: var(--agilo-error);
    text-decoration: underline;
    text-underline-offset: 2px;
  }
  .agf-hidden-field { display: none; }

  .agf-manual-auth { display: grid; gap: var(--space-1); }
  .agf-manual-auth.is-collapsed .agf-manual-auth-fields { display: none; }
  .agf-manual-auth-toggle { border: none; background: none; color: var(--agilo-primary); font-size: 0.8125rem; cursor: pointer; padding: 0; text-decoration: underline; text-underline-offset: 2px; }
  .agf-manual-auth-toggle:hover { color: var(--agilo-text); }
  .agf-manual-auth-fields { display: grid; gap: var(--space-1); }
  .agf-manual-auth label { font-size: 0.75rem; color: var(--agilo-text-secondary); display: block; margin-bottom: 2px; }
  .agf-manual-auth input { width: 100%; padding: 6px 8px; font-size: 0.8125rem; border: 1px solid var(--agilo-border); border-radius: 6px; }
  .agf-manual-auth select { width: 100%; padding: 6px 8px; font-size: 0.8125rem; border: 1px solid var(--agilo-border); border-radius: 6px; background: var(--agilo-surface); }

  @media (max-width: 980px) {
    .agf-grid { grid-template-columns: 1fr; }
    .agf-side { order: -1; }
  }
  @media (max-width: 760px) {
    .agf-tabs,
    .agf-row,
    .agf-cols,
    .agf-checkboxes,
    .agf-pseudo-grid,
    .agf-inc-grid { grid-template-columns: 1fr; }
    .agf-actions { flex-direction: column; align-items: stretch; }
    .agf-btn-primary,
    .agf-download { width: 100%; justify-content: center; text-align: center; }
  }
</style>

<form id="agfForm" ms-code-anonymisation="form" novalidate>
  <input type="hidden" name="memberEmail" data-ms-member-email="" ms-code-member-email>

  <section class="agf-shell" aria-label="Anonymisation avancée">
    <header class="agf-head">
      <h2>Anonymisation documentaire</h2>
      <p>Flux unifié pour fichiers, texte et restauration avec gouvernance de sécurité.</p>
    </header>

    <div class="agf-tabs" role="tablist" aria-label="Modes de traitement">
      <button id="agfTab-file" class="agf-tab" type="button" role="tab" aria-selected="true" aria-controls="agfPanel-file" data-tab="file">
        <strong>Traitement de fichier</strong>
        <span>PDF, Image, CSV, FEC, etc.</span>
      </button>
      <button id="agfTab-text" class="agf-tab" type="button" role="tab" aria-selected="false" aria-controls="agfPanel-text" data-tab="text">
        <strong>Traitement de texte</strong>
        <span>Email, Markdown, etc.</span>
      </button>
      <button id="agfTab-restore" class="agf-tab" type="button" role="tab" aria-selected="false" aria-controls="agfPanel-restore" data-tab="restore">
        <strong>Restauration</strong>
        <span>Restaurez les données pseudonymisées</span>
      </button>
    </div>

    <div class="agf-grid">
      <div class="agf-main">
        <section id="agfPanel-file" class="agf-panel" role="tabpanel" aria-labelledby="agfTab-file" aria-hidden="false">
          <h3 class="agf-section-title">Sélectionnez les fichiers</h3>
          <div id="agfDropzone" class="agf-dropzone" role="button" tabindex="0" aria-label="Zone de dépôt fichiers">
            <h4>Cliquez ou glissez-déposez des fichiers</h4>
            <p>PDF, Word, Excel, images et autres formats courants (10 Mo max / fichier).</p>
            <p class="agf-formats-explicit">Formats pris en charge : CSV, Word (doc, docx), PowerPoint (ppt, pptx), Excel (xls, xlsx), TXT.</p>
          </div>
          <input id="agfFileInput" type="file" name="fileUpload[]" multiple accept=".pdf,.doc,.docx,.xls,.xlsx,.csv,.ppt,.pptx,.txt,.json,.fec,.png,.jpg,.jpeg,application/pdf,application/msword,application/vnd.openxmlformats-officedocument.wordprocessingml.document,application/vnd.ms-excel,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,text/csv,application/vnd.ms-powerpoint,application/vnd.openxmlformats-officedocument.presentationml.presentation,text/plain,application/json,image/png,image/jpeg">

          <h3 class="agf-section-title">Fichiers à anonymiser</h3>
          <div id="agfFileList" class="agf-list" role="list"></div>

          <div id="agfStatus" class="agf-status" role="status" aria-live="polite"></div>

          <div class="agf-actions">
            <button id="agfSubmit" type="submit" class="agf-btn-primary" disabled>Anonymiser les fichiers</button>
            <button id="agfReset" type="button" class="agf-btn-secondary">Effacer</button>
            <a id="agfDownload" href="#" class="agf-download" download>Télécharger le résultat</a>
          </div>
        </section>

        <section id="agfPanel-text" class="agf-panel" role="tabpanel" aria-labelledby="agfTab-text" aria-hidden="true">
          <div class="agf-row agf-row--text">
            <div class="agf-textbox agf-textbox--flex">
              <div class="agf-textbox-head">
                <label for="agfInputText">Saisissez le texte</label>
                <button id="agfTextClear" type="button" class="agf-btn-link agf-btn-link--small" aria-label="Effacer le texte"><span class="agf-icon-trash" aria-hidden="true"></span>Effacer le texte</button>
              </div>
              <div class="agf-textbox-body">
                <textarea id="agfInputText" class="agf-textarea" placeholder="Tapez ou collez votre texte ici..."></textarea>
              </div>
            </div>
            <div class="agf-textbox agf-textbox--flex">
              <label class="agf-textbox-label">Texte traité</label>
              <div class="agf-output-wrap" id="agfOutputWrap">
                <button id="agfTextCopy" type="button" class="agf-output-copy" aria-label="Copier"><span class="agf-icon-copy" aria-hidden="true"></span>Copier</button>
                <div id="agfOutputText" class="agf-text-output" role="region" aria-live="polite">Le texte traité apparaîtra ici</div>
                <div id="agfOutputStats" class="agf-output-stats" aria-live="polite">
                  <p id="agfOutputSummary" class="agf-output-summary">Aucun champ anonymisé détecté pour l'instant.</p>
                  <div id="agfOutputEntities" class="agf-output-entities"></div>
                </div>
              </div>
            </div>
          </div>
          <p class="agf-small">Traitement automatique à la saisie (sans bouton).</p>
        </section>


        <section id="agfPanel-restore" class="agf-panel" role="tabpanel" aria-labelledby="agfTab-restore" aria-hidden="true">
          <div class="agf-lock-block" id="agfRestoreLocked">
            <svg class="agf-lock-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
              <rect x="3" y="11" width="18" height="10" rx="2" stroke="currentColor" stroke-width="1.6"/>
              <path d="M7 11V8a5 5 0 0110 0v3" stroke="currentColor" stroke-width="1.6"/>
              <circle cx="12" cy="16" r="1.2" fill="currentColor"/>
            </svg>
            <p class="agf-lock-title">Restauration des pseudonymes</p>
            <p class="agf-lock-text">Module de restauration prêt côté interface. L'activation backend sera branchée dès validation du mapping sécurisé.</p>
            <button id="agfUpgradeRestore" type="button" class="agf-btn-primary">Préparer la gouvernance</button>
          </div>
        </section>
      </div>

      <aside class="agf-side" aria-label="Paramètres">
        <div class="agf-group agf-manual-auth is-collapsed" id="agfManualAuth">
          <p class="agf-label">Connexion API</p>
          <button type="button" class="agf-manual-auth-toggle" id="agfManualAuthToggle" aria-expanded="false" aria-controls="agfManualAuthFields">Utiliser des identifiants manuels</button>
          <div class="agf-manual-auth-fields" id="agfManualAuthFields" aria-hidden="true">
            <label for="agfManualUsername">Username (email)</label>
            <input type="text" id="agfManualUsername" name="agfManualUsername" placeholder="email@exemple.com" autocomplete="username">
            <label for="agfManualToken">Token</label>
            <input type="text" id="agfManualToken" name="agfManualToken" placeholder="Token API" autocomplete="off">
            <label for="agfManualEdition">Edition</label>
            <select id="agfManualEdition" name="agfManualEdition">
              <option value="free">free</option>
              <option value="pro">pro</option>
              <option value="ent">ent</option>
              <option value="anonymisation">anonymisation</option>
            </select>
          </div>
        </div>

        <div class="agf-group">
          <p class="agf-label">Mode de traitement</p>
          <label class="agf-radio-line"><input type="radio" name="agfMode" value="anonymiser" checked> Anonymiser</label>
          <button id="agfPseudoMode" type="button" class="agf-item-btn"><span>Pseudonymiser</span><span class="agf-chip" id="agfPseudoBadge">Paramétrer</span></button>
        </div>

        <div class="agf-group">
          <p class="agf-label">Paramètres</p>
          <button id="agfOpenTypes" type="button" class="agf-item-btn agf-item-btn--count">
            <span>Types de données</span>
            <span class="agf-chip-count" id="agfTypesCount">17</span>
          </button>
          <button id="agfOpenInclusion" type="button" class="agf-item-btn"><span>Inclusion / Exclusion</span><span id="agfInclusionChip" class="agf-chip">0 / 0</span></button>
        </div>

        <div class="agf-group">
          <p class="agf-label">Enregistré</p>
          <button id="agfPseudoSaved" type="button" class="agf-item-btn"><span>Pseudonymes</span><span class="agf-chip">Gérer</span></button>
          <p id="agfPseudoSummary" class="agf-small">Pseudo: configuration standard</p>
          <p id="agfSavedTypesInfo" class="agf-small">Types actifs: 0</p>
          <p id="agfLastMaskInfo" class="agf-small">Champs anonymisés (texte): 0</p>
        </div>

        <p id="agfApiMeta" class="agf-small">API: vérification...</p>
        <p class="agf-small"><a href="https://api.agilotext.com/html/menu.html" target="_blank" rel="noopener noreferrer" id="agfApiLink">API Agilotext</a></p>
      </aside>
    </div>
  </section>
</form>

<div id="agfModalTypesWrap" class="agf-modal-overlay" role="dialog" aria-modal="true" aria-labelledby="agfModalTypesTitle" aria-hidden="true">
  <div class="agf-modal">
    <div class="agf-modal-head">
      <div>
        <h3 id="agfModalTypesTitle" class="agf-modal-title">Sélectionnez les types de données</h3>
        <p class="agf-modal-subtitle">Ces préférences sont enregistrées et appliquées aux prochains traitements.</p>
      </div>
      <button id="agfModalTypesClose" type="button" class="agf-close" aria-label="Fermer">&times;</button>
    </div>

    <div class="agf-type-grid" id="agfTypeGrid">
      <section class="agf-type-card" data-type-group="person">
        <div class="agf-type-card-head">
          <h5>Données personnelles</h5>
          <span class="agf-type-card-count" id="agfGroupCount-person">0</span>
        </div>
        <div class="agf-checkboxes">
          <label class="agf-entity-option"><input type="checkbox" data-entity="PR" data-api="person_name" checked><span class="agf-entity-code">PR</span><span class="agf-entity-name">Nom de personne</span></label>
          <label class="agf-entity-option"><input type="checkbox" data-entity="MAIL" data-api="email" checked><span class="agf-entity-code">MAIL</span><span class="agf-entity-name">Adresse email</span></label>
          <label class="agf-entity-option"><input type="checkbox" data-entity="PHON" data-api="phone" checked><span class="agf-entity-code">PHON</span><span class="agf-entity-name">Téléphone</span></label>
          <label class="agf-entity-option"><input type="checkbox" data-entity="AGE" data-api="birth" checked><span class="agf-entity-code">AGE</span><span class="agf-entity-name">Âge / naissance</span></label>
          <label class="agf-entity-option"><input type="checkbox" data-entity="TR" data-api="role" checked><span class="agf-entity-code">TR</span><span class="agf-entity-name">Titre / profession</span></label>
          <label class="agf-entity-option"><input type="checkbox" data-entity="DT" data-api="" checked><span class="agf-entity-code">DT</span><span class="agf-entity-name">Date et heure</span></label>
        </div>
      </section>

      <section class="agf-type-card" data-type-group="company">
        <div class="agf-type-card-head">
          <h5>Données d'entreprise</h5>
          <span class="agf-type-card-count" id="agfGroupCount-company">0</span>
        </div>
        <div class="agf-checkboxes">
          <label class="agf-entity-option"><input type="checkbox" data-entity="CIE" data-api="company" checked><span class="agf-entity-code">CIE</span><span class="agf-entity-name">Nom d'entreprise</span></label>
          <label class="agf-entity-option"><input type="checkbox" data-entity="CID" data-api="siren" checked><span class="agf-entity-code">CID</span><span class="agf-entity-name">Identifiant administratif</span></label>
          <label class="agf-entity-option"><input type="checkbox" data-entity="ACT" data-api="accounting" checked><span class="agf-entity-code">ACT</span><span class="agf-entity-name">Entrée comptable</span></label>
          <label class="agf-entity-option"><input type="checkbox" data-entity="PROD" data-api="product" checked><span class="agf-entity-code">PROD</span><span class="agf-entity-name">Produit / service</span></label>
          <label class="agf-entity-option"><input type="checkbox" data-entity="ORG" data-api="company" checked><span class="agf-entity-code">ORG</span><span class="agf-entity-name">Organisation</span></label>
          <label class="agf-entity-option is-future"><input type="checkbox" data-entity="FILE" data-api=""><span class="agf-entity-code">FILE</span><span class="agf-entity-name">Nom de dossier</span></label>
        </div>
      </section>

      <section class="agf-type-card" data-type-group="location">
        <div class="agf-type-card-head">
          <h5>Données de localisation</h5>
          <span class="agf-type-card-count" id="agfGroupCount-location">0</span>
        </div>
        <div class="agf-checkboxes">
          <label class="agf-entity-option"><input type="checkbox" data-entity="ADR" data-api="address" checked><span class="agf-entity-code">ADR</span><span class="agf-entity-name">Adresse</span></label>
          <label class="agf-entity-option"><input type="checkbox" data-entity="POST" data-api="address" checked><span class="agf-entity-code">POST</span><span class="agf-entity-name">Code postal</span></label>
          <label class="agf-entity-option"><input type="checkbox" data-entity="LOC" data-api="address" checked><span class="agf-entity-code">LOC</span><span class="agf-entity-name">Ville / région</span></label>
          <label class="agf-entity-option is-future"><input type="checkbox" data-entity="GEO" data-api=""><span class="agf-entity-code">GEO</span><span class="agf-entity-name">Géolocalisation</span></label>
        </div>
      </section>

      <section class="agf-type-card" data-type-group="finance">
        <div class="agf-type-card-head">
          <h5>Données financières</h5>
          <span class="agf-type-card-count" id="agfGroupCount-finance">0</span>
        </div>
        <div class="agf-checkboxes">
          <label class="agf-entity-option"><input type="checkbox" data-entity="BANK" data-api="bank" checked><span class="agf-entity-code">BANK</span><span class="agf-entity-name">Compte bancaire</span></label>
          <label class="agf-entity-option"><input type="checkbox" data-entity="CARD" data-api="bank" checked><span class="agf-entity-code">CARD</span><span class="agf-entity-name">Carte bancaire</span></label>
          <label class="agf-entity-option"><input type="checkbox" data-entity="REF" data-api="contract" checked><span class="agf-entity-code">REF</span><span class="agf-entity-name">Numéro de référence</span></label>
          <label class="agf-entity-option is-future"><input type="checkbox" data-entity="MT" data-api=""><span class="agf-entity-code">MT</span><span class="agf-entity-name">Montant</span></label>
          <label class="agf-entity-option is-future"><input type="checkbox" data-entity="IBAN" data-api=""><span class="agf-entity-code">IBAN</span><span class="agf-entity-name">IBAN</span></label>
        </div>
      </section>

      <section class="agf-type-card" data-type-group="misc">
        <div class="agf-type-card-head">
          <h5>Données diverses</h5>
          <span class="agf-type-card-count" id="agfGroupCount-misc">0</span>
        </div>
        <div class="agf-checkboxes">
          <label class="agf-entity-option is-future"><input type="checkbox" data-entity="URL" data-api=""><span class="agf-entity-code">URL</span><span class="agf-entity-name">URL</span></label>
          <label class="agf-entity-option is-future"><input type="checkbox" data-entity="IP" data-api=""><span class="agf-entity-code">IP</span><span class="agf-entity-name">Adresse IP</span></label>
          <label class="agf-entity-option"><input type="checkbox" data-entity="CLAUSE" data-api="contract"><span class="agf-entity-code">CLAUSE</span><span class="agf-entity-name">Clause sensible</span></label>
        </div>
      </section>

      <section class="agf-type-card" data-type-group="france">
        <div class="agf-type-card-head">
          <h5>Formats spécifiques France</h5>
          <span class="agf-type-card-count" id="agfGroupCount-france">0</span>
        </div>
        <div class="agf-checkboxes">
          <label class="agf-entity-option is-future"><input type="checkbox" data-entity="FRNIR" data-api=""><span class="agf-entity-code">FRNIR</span><span class="agf-entity-name">NIR</span></label>
          <label class="agf-entity-option is-future"><input type="checkbox" data-entity="FRPASS" data-api=""><span class="agf-entity-code">FRPASS</span><span class="agf-entity-name">Passeport</span></label>
          <label class="agf-entity-option is-future"><input type="checkbox" data-entity="FRCNI" data-api=""><span class="agf-entity-code">FRCNI</span><span class="agf-entity-name">Carte d'identité</span></label>
        </div>
      </section>
    </div>

    <div class="agf-modal-actions">
      <div class="agf-actions">
        <button id="agfDefaultsTypes" type="button" class="agf-btn-secondary">Paramètres par défaut</button>
        <button id="agfDetectAllTypes" type="button" class="agf-btn-link">Tout détecter</button>
        <button id="agfIgnoreAllTypes" type="button" class="agf-btn-link">Tout ignorer</button>
      </div>
      <button id="agfSaveTypes" type="button" class="agf-btn-primary">Enregistrer</button>
    </div>
  </div>
</div>

<div id="agfModalPseudoWrap" class="agf-modal-overlay" role="dialog" aria-modal="true" aria-labelledby="agfModalPseudoTitle" aria-hidden="true">
  <div class="agf-modal agf-modal--wide">
    <div class="agf-modal-head">
      <div>
        <h3 id="agfModalPseudoTitle" class="agf-modal-title">Pseudonymisation pilotée</h3>
        <p class="agf-modal-subtitle">Définissez une politique robuste de pseudonymisation. L'interface est prête et les paramètres seront appliqués sans rupture lors de l'activation backend.</p>
      </div>
      <button id="agfModalPseudoClose" type="button" class="agf-close" aria-label="Fermer">&times;</button>
    </div>

    <div class="agf-pseudo-grid">
      <section class="agf-pseudo-card">
        <p class="agf-pseudo-title">Stratégie de remplacement</p>
        <p class="agf-pseudo-desc">Détermine le format des valeurs pseudonymisées dans les résultats et exports.</p>
        <div class="agf-option-line">
          <input id="agfPseudoStrategyPlaceholders" type="radio" name="agfPseudoStrategy" value="placeholders" checked>
          <label for="agfPseudoStrategyPlaceholders">Identifiants lisibles (ex: [PR-0001])</label>
        </div>
        <div class="agf-option-line">
          <input id="agfPseudoStrategyStable" type="radio" name="agfPseudoStrategy" value="stable_hash">
          <label for="agfPseudoStrategyStable">Jeton stable (hash cohérent)</label>
        </div>
        <div class="agf-option-line">
          <input id="agfPseudoStrategyAlias" type="radio" name="agfPseudoStrategy" value="human_alias">
          <label for="agfPseudoStrategyAlias">Alias métier (lecture humaine contrôlée)</label>
        </div>
        <div class="agf-select-line">
          <label for="agfPseudoScope">Périmètre de cohérence</label>
          <select id="agfPseudoScope">
            <option value="document">Document</option>
            <option value="batch">Lot de fichiers</option>
            <option value="workspace">Espace client</option>
          </select>
        </div>
      </section>

      <section class="agf-pseudo-card">
        <p class="agf-pseudo-title">Sécurité et restauration</p>
        <p class="agf-pseudo-desc">Définit la gouvernance de clé et la politique de restauration.</p>
        <div class="agf-select-line">
          <label for="agfPseudoKeyMode">Gestion de clé</label>
          <select id="agfPseudoKeyMode">
            <option value="server">Clé serveur managée</option>
            <option value="client">Clé client (BYOK)</option>
            <option value="hsm">HSM / KMS dédié</option>
          </select>
        </div>
        <div class="agf-select-line">
          <label for="agfPseudoRestoreWindow">Fenêtre de restauration</label>
          <select id="agfPseudoRestoreWindow">
            <option value="24h">24 heures</option>
            <option value="7d">7 jours</option>
            <option value="30d" selected>30 jours</option>
            <option value="never">Aucune restauration</option>
          </select>
        </div>
        <div class="agf-option-line">
          <input id="agfPseudoDeterministic" type="checkbox" checked>
          <label for="agfPseudoDeterministic">Même donnée source -> même pseudonyme</label>
        </div>
        <div class="agf-option-line">
          <input id="agfPseudoPreserveFormat" type="checkbox" checked>
          <label for="agfPseudoPreserveFormat">Préserver la structure (longueur, séparateurs)</label>
        </div>
      </section>
    </div>

    <div class="agf-modal-actions">
      <button id="agfPseudoDefaults" type="button" class="agf-btn-secondary">Réinitialiser</button>
      <button id="agfSavePseudo" type="button" class="agf-btn-primary">Enregistrer la politique</button>
    </div>
  </div>
</div>

<div id="agfModalInclusionWrap" class="agf-modal-overlay" role="dialog" aria-modal="true" aria-labelledby="agfModalIncTitle" aria-hidden="true">
  <div class="agf-modal agf-modal--wide">
    <div class="agf-modal-head">
      <div>
        <h3 id="agfModalIncTitle" class="agf-modal-title">Inclusion / Exclusion</h3>
        <p class="agf-modal-subtitle">Gérez les listes d'inclusion et d'exclusion pour réduire les faux positifs et faux négatifs. La comparaison ignore la casse et les accents.</p>
      </div>
      <button id="agfModalIncClose" type="button" class="agf-close" aria-label="Fermer">&times;</button>
    </div>

    <div class="agf-inc-grid">
      <section class="agf-inc-card agf-inc-card--include">
        <h4>Liste d'inclusion</h4>
        <p>Ces termes sont toujours détectés et anonymisés, même hors des types sélectionnés.</p>
        <div class="agf-inc-add">
          <input id="agfIncludeInput" type="text" placeholder="Ajouter un terme à inclure...">
          <button id="agfIncludeAdd" type="button">Ajouter</button>
        </div>
        <div id="agfIncludeList" class="agf-term-list" aria-live="polite"></div>
      </section>

      <section class="agf-inc-card agf-inc-card--exclude">
        <h4>Liste d'exclusion</h4>
        <p>Ces termes sont systématiquement ignorés lors de l'anonymisation, même s'ils correspondent aux types sélectionnés.</p>
        <div class="agf-inc-add">
          <input id="agfExcludeInput" type="text" placeholder="Ajouter un terme à exclure...">
          <button id="agfExcludeAdd" type="button">Ajouter</button>
        </div>
        <div id="agfExcludeList" class="agf-term-list" aria-live="polite"></div>
      </section>
    </div>

    <div class="agf-modal-actions">
      <span id="agfIncSummary" class="agf-small">Inclusion: 0 · Exclusion: 0</span>
      <div class="agf-actions">
        <button id="agfInclusionDefaults" type="button" class="agf-btn-secondary">Vider les listes</button>
        <button id="agfSaveInclusion" type="button" class="agf-btn-primary">Enregistrer les listes</button>
      </div>
    </div>

    <textarea id="agfIncludeTerms" class="agf-hidden-field" aria-hidden="true"></textarea>
    <textarea id="agfExcludeTerms" class="agf-hidden-field" aria-hidden="true"></textarea>
  </div>
</div>

<script>
(function () {
  'use strict';

  const API_BASE = 'https://api.agilotext.com/api/v1';
  const TOKEN_ENDPOINT = API_BASE + '/getToken';
  const ANON_ENDPOINT = API_BASE + '/anonOfficeText';
  const ANON_TEXT_ENDPOINT = API_BASE + '/anonText';
  const CLEANUP_ENDPOINT = API_BASE + '/cleanupOldJobs';
  const VERSION_ENDPOINT = API_BASE + '/getVersion';
  const MAX_FILE_SIZE = 10 * 1024 * 1024;
  const SUPPORTED_EXT = ['pdf', 'doc', 'docx', 'xls', 'xlsx', 'csv', 'ppt', 'pptx', 'txt', 'json', 'fec', 'png', 'jpg', 'jpeg'];
  const REQUEST_TIMEOUT = 180000;

  const STORAGE_TYPES = 'agilo:futures:types:v1';
  const STORAGE_INC = 'agilo:futures:include:v1';
  const STORAGE_EXC = 'agilo:futures:exclude:v1';
  const STORAGE_PSEUDO = 'agilo:futures:pseudo:v1';
  const STORAGE_MODE = 'agilo:futures:mode:v1';

  const DEFAULT_PSEUDO_CONFIG = {
    strategy: 'placeholders',
    scope: 'document',
    keyMode: 'server',
    restoreWindow: '30d',
    deterministic: true,
    preserveFormat: true
  };

  const state = {
    activeTab: 'file',
    files: [],
    edition: 'free',
    mode: 'anonymiser',
    email: null,
    token: '',
    processing: false,
    resultUrl: null,
    resultFilename: 'document_anonymise',
    textProcessing: false,
    includeTerms: [],
    excludeTerms: [],
    pseudoConfig: { ...DEFAULT_PSEUDO_CONFIG }
  };
  const DEBOUNCE_TEXT_MS = 300;
  let debounceTextTimer = null;
  let lastProcessedText = null;
  let lastProcessedResult = null;
  let lastProcessedHasTags = false;
  let lastProcessedHtml = null;
  const ENTITY_TYPES_TAG = ['PR', 'MAIL', 'PHON', 'AGE', 'TR', 'CIE', 'CID', 'ACT', 'PROD', 'ADR', 'POST', 'LOC', 'GEO', 'CARD', 'BANK', 'MT', 'IBAN', 'ORG', 'URL', 'IP', 'REF', 'FILE', 'CLAUSE', 'DT', 'FRNIR', 'FRPASS', 'FRCNI', 'SIREN', 'SIRET', 'OTHER'];
  const PLACEHOLDER_RE = /\[([A-Z0-9_]{2,12})\]/g;
  const API_READY_VALUES = ['person_name', 'email', 'phone', 'birth', 'role', 'address', 'company', 'siren', 'accounting', 'product', 'contract', 'bank'];

  const ui = {
    form: document.getElementById('agfForm'),
    tabs: Array.from(document.querySelectorAll('.agf-tab')),
    panels: { file: document.getElementById('agfPanel-file'), text: document.getElementById('agfPanel-text'), restore: document.getElementById('agfPanel-restore') },
    dropzone: document.getElementById('agfDropzone'),
    input: document.getElementById('agfFileInput'),
    fileList: document.getElementById('agfFileList'),
    submit: document.getElementById('agfSubmit'),
    reset: document.getElementById('agfReset'),
    download: document.getElementById('agfDownload'),
    status: document.getElementById('agfStatus'),
    textInput: document.getElementById('agfInputText'),
    textOutput: document.getElementById('agfOutputText'),
    textClear: document.getElementById('agfTextClear'),
    textCopy: document.getElementById('agfTextCopy'),
    outputSummary: document.getElementById('agfOutputSummary'),
    outputEntities: document.getElementById('agfOutputEntities'),
    savedTypesInfo: document.getElementById('agfSavedTypesInfo'),
    lastMaskInfo: document.getElementById('agfLastMaskInfo'),
    pseudoSummary: document.getElementById('agfPseudoSummary'),
    pseudoBadge: document.getElementById('agfPseudoBadge'),
    modeRadios: Array.from(document.querySelectorAll('input[name="agfMode"]')),
    pseudoMode: document.getElementById('agfPseudoMode'),
    pseudoSaved: document.getElementById('agfPseudoSaved'),
    openTypes: document.getElementById('agfOpenTypes'),
    openInclusion: document.getElementById('agfOpenInclusion'),
    inclusionChip: document.getElementById('agfInclusionChip'),
    typesCount: document.getElementById('agfTypesCount'),
    upgradeRestore: document.getElementById('agfUpgradeRestore'),
    apiMeta: document.getElementById('agfApiMeta'),
    modals: {
      types: document.getElementById('agfModalTypesWrap'),
      pseudo: document.getElementById('agfModalPseudoWrap'),
      inclusion: document.getElementById('agfModalInclusionWrap')
    },
    modalTypesClose: document.getElementById('agfModalTypesClose'),
    modalPseudoClose: document.getElementById('agfModalPseudoClose'),
    modalIncClose: document.getElementById('agfModalIncClose'),
    defaultsTypes: document.getElementById('agfDefaultsTypes'),
    detectAllTypes: document.getElementById('agfDetectAllTypes'),
    ignoreAllTypes: document.getElementById('agfIgnoreAllTypes'),
    pseudoDefaults: document.getElementById('agfPseudoDefaults'),
    savePseudo: document.getElementById('agfSavePseudo'),
    pseudoStrategyRadios: Array.from(document.querySelectorAll('input[name="agfPseudoStrategy"]')),
    pseudoScope: document.getElementById('agfPseudoScope'),
    pseudoKeyMode: document.getElementById('agfPseudoKeyMode'),
    pseudoRestoreWindow: document.getElementById('agfPseudoRestoreWindow'),
    pseudoDeterministic: document.getElementById('agfPseudoDeterministic'),
    pseudoPreserveFormat: document.getElementById('agfPseudoPreserveFormat'),
    saveTypes: document.getElementById('agfSaveTypes'),
    saveInclusion: document.getElementById('agfSaveInclusion'),
    inclusionDefaults: document.getElementById('agfInclusionDefaults'),
    incSummary: document.getElementById('agfIncSummary'),
    includeTerms: document.getElementById('agfIncludeTerms'),
    excludeTerms: document.getElementById('agfExcludeTerms'),
    includeInput: document.getElementById('agfIncludeInput'),
    excludeInput: document.getElementById('agfExcludeInput'),
    includeAdd: document.getElementById('agfIncludeAdd'),
    excludeAdd: document.getElementById('agfExcludeAdd'),
    includeList: document.getElementById('agfIncludeList'),
    excludeList: document.getElementById('agfExcludeList'),
    manualAuth: document.getElementById('agfManualAuth'),
    manualAuthToggle: document.getElementById('agfManualAuthToggle'),
    manualAuthFields: document.getElementById('agfManualAuthFields'),
    manualUsername: document.getElementById('agfManualUsername'),
    manualToken: document.getElementById('agfManualToken'),
    manualEdition: document.getElementById('agfManualEdition')
  };

  const DEFAULT_ENTITIES = ['PR', 'MAIL', 'PHON', 'AGE', 'TR', 'CIE', 'CID', 'ACT', 'PROD', 'ADR', 'POST', 'LOC', 'BANK', 'CARD', 'REF', 'CLAUSE', 'DT'];
  const uid = () => Date.now().toString(36) + Math.random().toString(36).slice(2);
  const formatSize = (bytes) => {
    if (!bytes) return '0 B';
    const units = ['B', 'KB', 'MB', 'GB'];
    const idx = Math.min(Math.floor(Math.log(bytes) / Math.log(1024)), units.length - 1);
    return (bytes / Math.pow(1024, idx)).toFixed(idx === 0 ? 0 : 2) + ' ' + units[idx];
  };

  function setStatus(kind, message) {
    if (!message) {
      ui.status.classList.remove('is-visible');
      ui.status.removeAttribute('data-kind');
      ui.status.textContent = '';
      return;
    }
    ui.status.classList.add('is-visible');
    ui.status.setAttribute('data-kind', kind);
    ui.status.textContent = '';
    if (kind === 'loading') {
      const spinner = document.createElement('span');
      spinner.className = 'agf-spinner';
      spinner.setAttribute('aria-hidden', 'true');
      ui.status.appendChild(spinner);
    }
    const txt = document.createElement('span');
    txt.textContent = message;
    ui.status.appendChild(txt);
  }

  let lastFocusBeforeModal = null;
  function openModal(el) {
    if (!el) return;
    lastFocusBeforeModal = document.activeElement;
    el.classList.add('is-open');
    el.setAttribute('aria-hidden', 'false');
    const closeBtn = el.querySelector('.agf-close');
    if (closeBtn) setTimeout(() => closeBtn.focus(), 0);
  }
  function closeModal(el) {
    if (!el) return;
    el.classList.remove('is-open');
    el.setAttribute('aria-hidden', 'true');
    if (lastFocusBeforeModal && typeof lastFocusBeforeModal.focus === 'function') {
      setTimeout(() => lastFocusBeforeModal.focus(), 0);
    }
  }
  function closeAllModals() { Object.keys(ui.modals).forEach((k) => closeModal(ui.modals[k])); }

  function revokeResultUrl() {
    if (state.resultUrl) {
      URL.revokeObjectURL(state.resultUrl);
      state.resultUrl = null;
    }
  }

  function updateActions() { ui.submit.disabled = state.processing || state.files.length === 0; }

  function renderFileList() {
    ui.fileList.textContent = '';
    if (state.files.length === 0) {
      const empty = document.createElement('div');
      empty.className = 'agf-empty';
      empty.textContent = 'Les fichiers sélectionnés apparaîtront ici';
      ui.fileList.appendChild(empty);
      updateActions();
      return;
    }
    state.files.forEach((item) => {
      const row = document.createElement('div');
      row.className = 'agf-file';
      row.setAttribute('role', 'listitem');

      const left = document.createElement('div');
      const name = document.createElement('p');
      name.className = 'agf-file-name';
      name.title = item.fileName;
      name.textContent = item.fileName;
      const meta = document.createElement('p');
      meta.className = 'agf-file-meta';
      meta.textContent = formatSize(item.size);
      left.appendChild(name);
      left.appendChild(meta);

      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'agf-remove';
      btn.textContent = 'Retirer';
      btn.addEventListener('click', function () {
        if (state.processing) return;
        state.files = state.files.filter((f) => f.id !== item.id);
        renderFileList();
      });

      row.appendChild(left);
      row.appendChild(btn);
      ui.fileList.appendChild(row);
    });
    updateActions();
  }

  function validateFile(file) {
    if (!file || file.size > MAX_FILE_SIZE) return false;
    const ext = (file.name.split('.').pop() || '').toLowerCase();
    return SUPPORTED_EXT.includes(ext);
  }

  function addFiles(fileList) {
    const files = Array.from(fileList || []);
    const rejected = [];
    files.forEach((file) => {
      if (!validateFile(file)) { rejected.push(file.name); return; }
      state.files.push({ id: uid(), file, fileName: file.name, size: file.size });
    });
    if (rejected.length > 0) {
      const short = rejected.slice(0, 2).join(', ');
      const more = rejected.length > 2 ? ' +' + (rejected.length - 2) + ' autre(s)' : '';
      setStatus('error', 'Format non supporté ou fichier > 10 Mo : ' + short + more + '.');
    } else {
      setStatus('', '');
    }
    renderFileList();
  }

  function setActiveTab(tab) {
    state.activeTab = tab;
    ui.tabs.forEach((btn) => {
      const isActive = btn.getAttribute('data-tab') === tab;
      btn.setAttribute('aria-selected', isActive ? 'true' : 'false');
    });
    Object.keys(ui.panels).forEach((key) => {
      const active = key === tab;
      ui.panels[key].setAttribute('aria-hidden', active ? 'false' : 'true');
    });
  }

  function selectedVisualEntities() {
    return Array.from(document.querySelectorAll('#agfTypeGrid input[type="checkbox"][data-entity]'))
      .filter((c) => c.checked)
      .map((c) => c.getAttribute('data-entity'));
  }

  function selectedEntities() {
    const values = [];
    Array.from(document.querySelectorAll('#agfTypeGrid input[type="checkbox"][data-entity]')).forEach((c) => {
      if (!c.checked) return;
      const apiValue = (c.getAttribute('data-api') || '').trim();
      if (!apiValue || !API_READY_VALUES.includes(apiValue)) return;
      if (!values.includes(apiValue)) values.push(apiValue);
    });
    return values;
  }

  function renderTypeCount() {
    const total = selectedVisualEntities().length;
    const apiReady = selectedEntities().length;
    ui.typesCount.textContent = String(total);
    if (ui.savedTypesInfo) ui.savedTypesInfo.textContent = 'Types actifs: ' + total + ' (API actifs: ' + apiReady + ')';

    Array.from(document.querySelectorAll('#agfTypeGrid .agf-type-card')).forEach((card) => {
      const selectedInGroup = card.querySelectorAll('input[type="checkbox"][data-entity]:checked').length;
      const badge = card.querySelector('.agf-type-card-count');
      if (badge) badge.textContent = String(selectedInGroup);
    });
  }

  function normalizeTerm(raw) {
    return (raw || '').replace(/\s+/g, ' ').trim();
  }

  function normalizeTermKey(raw) {
    return normalizeTerm(raw)
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '')
      .toLowerCase();
  }

  function parseStoredTerms(raw) {
    if (!raw) return [];
    const t = String(raw).trim();
    if (!t) return [];
    let terms = [];
    if (t.charAt(0) === '[') {
      try {
        const arr = JSON.parse(t);
        if (Array.isArray(arr)) terms = arr.map((x) => normalizeTerm(x)).filter(Boolean);
      } catch (e) {}
    }
    if (!terms.length) terms = t.split(/\r?\n/).map((x) => normalizeTerm(x)).filter(Boolean);
    const seen = new Set();
    return terms.filter((item) => {
      const key = normalizeTermKey(item);
      if (!key || seen.has(key)) return false;
      seen.add(key);
      return true;
    });
  }

  function syncHiddenTermFields() {
    if (ui.includeTerms) ui.includeTerms.value = state.includeTerms.join('\n');
    if (ui.excludeTerms) ui.excludeTerms.value = state.excludeTerms.join('\n');
  }

  function renderTermList(kind) {
    const list = kind === 'include' ? state.includeTerms : state.excludeTerms;
    const wrap = kind === 'include' ? ui.includeList : ui.excludeList;
    if (!wrap) return;

    wrap.textContent = '';
    if (!list.length) {
      const empty = document.createElement('p');
      empty.className = 'agf-term-empty';
      empty.textContent = kind === 'include'
        ? 'Aucun terme inclus pour le moment.'
        : 'Aucun terme exclu pour le moment.';
      wrap.appendChild(empty);
      return;
    }

    list.forEach((term, idx) => {
      const row = document.createElement('div');
      row.className = 'agf-term-item';
      const txt = document.createElement('span');
      txt.textContent = term;
      const rm = document.createElement('button');
      rm.type = 'button';
      rm.className = 'agf-term-remove';
      rm.textContent = 'Retirer';
      rm.addEventListener('click', () => {
        if (kind === 'include') state.includeTerms.splice(idx, 1);
        else state.excludeTerms.splice(idx, 1);
        syncHiddenTermFields();
        renderTermList(kind);
        renderInclusionSummary();
      });
      row.appendChild(txt);
      row.appendChild(rm);
      wrap.appendChild(row);
    });
  }

  function renderInclusionSummary() {
    const i = state.includeTerms.length;
    const e = state.excludeTerms.length;
    if (ui.incSummary) ui.incSummary.textContent = 'Inclusion: ' + i + ' · Exclusion: ' + e;
    if (ui.inclusionChip) ui.inclusionChip.textContent = i + ' / ' + e;
  }

  function addTerm(kind, rawValue) {
    const value = normalizeTerm(rawValue);
    if (!value) return false;
    const list = kind === 'include' ? state.includeTerms : state.excludeTerms;
    const key = normalizeTermKey(value);
    if (!key) return false;
    if (list.some((x) => normalizeTermKey(x) === key)) return false;
    list.push(value);
    syncHiddenTermFields();
    renderTermList(kind);
    renderInclusionSummary();
    return true;
  }

  function applyPseudoToUi(config) {
    if (!config) return;
    const strategy = config.strategy || DEFAULT_PSEUDO_CONFIG.strategy;
    if (ui.pseudoStrategyRadios && ui.pseudoStrategyRadios.length) {
      ui.pseudoStrategyRadios.forEach((r) => { r.checked = r.value === strategy; });
    }
    if (ui.pseudoScope) ui.pseudoScope.value = config.scope || DEFAULT_PSEUDO_CONFIG.scope;
    if (ui.pseudoKeyMode) ui.pseudoKeyMode.value = config.keyMode || DEFAULT_PSEUDO_CONFIG.keyMode;
    if (ui.pseudoRestoreWindow) ui.pseudoRestoreWindow.value = config.restoreWindow || DEFAULT_PSEUDO_CONFIG.restoreWindow;
    if (ui.pseudoDeterministic) ui.pseudoDeterministic.checked = config.deterministic !== false;
    if (ui.pseudoPreserveFormat) ui.pseudoPreserveFormat.checked = config.preserveFormat !== false;
  }

  function readPseudoFromUi() {
    const selectedRadio = (ui.pseudoStrategyRadios || []).find((r) => r.checked);
    return {
      strategy: selectedRadio ? selectedRadio.value : DEFAULT_PSEUDO_CONFIG.strategy,
      scope: ui.pseudoScope ? ui.pseudoScope.value : DEFAULT_PSEUDO_CONFIG.scope,
      keyMode: ui.pseudoKeyMode ? ui.pseudoKeyMode.value : DEFAULT_PSEUDO_CONFIG.keyMode,
      restoreWindow: ui.pseudoRestoreWindow ? ui.pseudoRestoreWindow.value : DEFAULT_PSEUDO_CONFIG.restoreWindow,
      deterministic: !!(ui.pseudoDeterministic && ui.pseudoDeterministic.checked),
      preserveFormat: !!(ui.pseudoPreserveFormat && ui.pseudoPreserveFormat.checked)
    };
  }

  function strategyLabel(strategy) {
    if (strategy === 'stable_hash') return 'Hash stable';
    if (strategy === 'human_alias') return 'Alias métier';
    return 'Placeholders';
  }

  function setMode(mode) {
    state.mode = mode === 'pseudonymiser' ? 'pseudonymiser' : 'anonymiser';
    const pseudoActive = state.mode === 'pseudonymiser';
    if (ui.pseudoMode) ui.pseudoMode.classList.toggle('is-active', pseudoActive);
    if (ui.pseudoBadge) ui.pseudoBadge.textContent = pseudoActive ? 'Actif' : 'Paramétrer';
    const anonRadio = (ui.modeRadios || []).find((r) => r.value === 'anonymiser');
    if (anonRadio) anonRadio.checked = !pseudoActive;
    try { localStorage.setItem(STORAGE_MODE, state.mode); } catch (e) {}
    renderPseudoSummary();
  }

  function renderPseudoSummary() {
    const cfg = state.pseudoConfig || DEFAULT_PSEUDO_CONFIG;
    if (ui.pseudoSummary) {
      const modeTxt = state.mode === 'pseudonymiser' ? 'actif' : 'configuré';
      ui.pseudoSummary.textContent =
        'Pseudo ' + modeTxt + ': ' + strategyLabel(cfg.strategy) + ' · clé ' + (cfg.keyMode || 'server') + ' · fenêtre ' + (cfg.restoreWindow || '30d');
    }
  }

  function loadPreferences() {
    let entities = DEFAULT_ENTITIES;
    const raw = localStorage.getItem(STORAGE_TYPES);
    if (raw) {
      try {
        const parsed = JSON.parse(raw);
        if (Array.isArray(parsed)) {
          const legacyMap = {
            person_name: 'PR',
            email: 'MAIL',
            phone: 'PHON',
            birth: 'AGE',
            role: 'TR',
            address: 'ADR',
            company: 'CIE',
            siren: 'CID',
            accounting: 'ACT',
            product: 'PROD',
            contract: 'REF',
            bank: 'BANK'
          };
          entities = parsed.map((item) => legacyMap[item] || item);
        }
      } catch (e) {}
    }
    Array.from(document.querySelectorAll('#agfTypeGrid input[type="checkbox"][data-entity]')).forEach((chk) => {
      chk.checked = entities.includes(chk.getAttribute('data-entity'));
    });

    state.includeTerms = parseStoredTerms(localStorage.getItem(STORAGE_INC));
    state.excludeTerms = parseStoredTerms(localStorage.getItem(STORAGE_EXC));
    syncHiddenTermFields();
    renderTermList('include');
    renderTermList('exclude');
    renderInclusionSummary();

    try {
      const pseudoRaw = localStorage.getItem(STORAGE_PSEUDO);
      if (pseudoRaw) {
        const parsed = JSON.parse(pseudoRaw);
        if (parsed && typeof parsed === 'object') state.pseudoConfig = { ...DEFAULT_PSEUDO_CONFIG, ...parsed };
      }
    } catch (e) {}
    applyPseudoToUi(state.pseudoConfig);
    renderPseudoSummary();
    const storedMode = localStorage.getItem(STORAGE_MODE);
    setMode(storedMode === 'pseudonymiser' ? 'pseudonymiser' : 'anonymiser');

    renderTypeCount();
  }

  async function waitForMemberstack(maxWait, interval) {
    const start = Date.now();
    while (Date.now() - start < maxWait) {
      if (window.$memberstackDom && typeof window.$memberstackDom.getCurrentMember === 'function') return true;
      await new Promise((resolve) => setTimeout(resolve, interval));
    }
    return false;
  }

  async function detectEdition() {
    const ms = window.$memberstackDom;
    if (ms && typeof ms.getCurrentMember === 'function') {
      try {
        const result = await ms.getCurrentMember({ cache: 'reload' });
        const member = result && result.data;
        if (member) {
          const ACTIVE = ['ACTIVE', 'TRIALING', 'GRACE'];
          const plans = member.planConnections || [];
          const hasPlan = (prefix) => plans.some((p) => ACTIVE.includes(p.status) && p.planId && p.planId.indexOf(prefix) === 0);
          const teams = member.teams || { belongsToTeam: false, ownedTeams: [] };
          if (teams.belongsToTeam && (teams.ownedTeams || []).length === 0) return 'ent';
          if (hasPlan('pln_business')) return 'ent';
          if (hasPlan('pln_pro')) return 'pro';
          if (hasPlan('pln_free')) return 'free';
          if (hasPlan('pln_anonymisation')) return 'anonymisation';
        }
      } catch (e) { console.warn('detectEdition error', e); }
    }

    const fromQuery = new URLSearchParams(window.location.search).get('edition');
    if (fromQuery) {
      const n = fromQuery.toLowerCase();
      if (['free', 'pro', 'ent', 'business', 'anonymisation'].includes(n)) return n === 'business' ? 'ent' : n;
    }
    const stored = localStorage.getItem('agilo:edition');
    if (stored && ['free', 'pro', 'ent', 'anonymisation'].includes(stored)) return stored;
    if (window.location.pathname.includes('/business/') || window.location.pathname.includes('/ent/')) return 'ent';
    if (window.location.pathname.includes('/pro/')) return 'pro';
    return 'free';
  }

  async function getUserEmail() {
    const ms = window.$memberstackDom;
    if (ms && typeof ms.getCurrentMember === 'function') {
      try {
        const result = await ms.getCurrentMember({ cache: 'reload' });
        const member = result && result.data;
        if (member && member.email) return member.email;
      } catch (e) { console.warn('getUserEmail error', e); }
    }
    return document.querySelector('[name="memberEmail"]')?.value || document.querySelector('[data-ms-member="email"]')?.textContent?.trim() || document.getElementById('memberEmail')?.value || null;
  }

  async function fetchWithTimeout(url, options, timeoutMs) {
    const controller = new AbortController();
    const timer = setTimeout(() => controller.abort(), timeoutMs);
    try {
      return await fetch(url, { ...options, signal: controller.signal, cache: 'no-store' });
    } finally { clearTimeout(timer); }
  }

  async function getToken(email, edition, retry) {
    const current = typeof retry === 'number' ? retry : 0;
    const maxRetry = 3;
    try {
      const url = TOKEN_ENDPOINT + '?username=' + encodeURIComponent(email) + '&edition=' + encodeURIComponent(edition);
      const response = await fetchWithTimeout(url, { method: 'GET' }, 20000);
      const data = await response.json();
      if (data && data.status === 'OK' && data.token) { state.token = data.token; return data.token; }
      throw new Error((data && (data.userErrorMessage || data.errorMessage)) || 'Token invalide');
    } catch (err) {
      if (current < maxRetry) {
        await new Promise((resolve) => setTimeout(resolve, 800 * (current + 1)));
        return getToken(email, edition, current + 1);
      }
      throw err;
    }
  }

  function getManualAuth() {
    const username = (ui.manualUsername && ui.manualUsername.value || '').trim();
    const token = (ui.manualToken && ui.manualToken.value || '').trim();
    const edition = (ui.manualEdition && ui.manualEdition.value || '').trim();
    if (username && token && edition) return { username, token, edition };
    return null;
  }

  async function ensureAuth() {
    const manual = getManualAuth();
    if (manual) {
      state.email = manual.username;
      state.token = manual.token;
      state.edition = manual.edition;
      return;
    }
    state.email = await getUserEmail();
    if (!state.email) throw new Error('Email utilisateur introuvable.');
    if (!state.token) await getToken(state.email, state.edition, 0);
  }

  async function runSessionMaintenance() {
    if (!state.email || !state.token) return;
    const cleanupUrl = CLEANUP_ENDPOINT + '?username=' + encodeURIComponent(state.email) + '&token=' + encodeURIComponent(state.token) + '&edition=' + encodeURIComponent(state.edition || 'free');
    try { await fetchWithTimeout(cleanupUrl, { method: 'GET' }, 15000); } catch (e) {}
  }

  async function loadApiVersion() {
    try {
      const response = await fetchWithTimeout(VERSION_ENDPOINT, { method: 'GET' }, 10000);
      if (!response.ok) return;
      const data = await response.json();
      if (data && data.status === 'OK' && data.version && ui.apiMeta) ui.apiMeta.textContent = 'API: ' + data.version;
    } catch (e) {}
  }

  function parseFilename(contentDisposition) {
    const match = (contentDisposition || '').match(/filename\*?=(?:UTF-8'')?([^;\n]+)/i);
    if (!match || !match[1]) return 'document_anonymise';
    return match[1].replace(/^['"]|['"]$/g, '').trim();
  }

  async function submitFiles(event) {
    event.preventDefault();
    if (state.activeTab !== 'file' || state.processing || state.files.length === 0) return;

    try { await ensureAuth(); } catch (e) { setStatus('error', e.message || 'Authentification indisponible.'); return; }

    state.processing = true;
    updateActions();
    revokeResultUrl();
    ui.download.href = '#';
    ui.download.removeAttribute('download');
    ui.download.classList.remove('is-visible');
    setStatus('loading', 'Traitement en cours...');

    const formData = new FormData();
    formData.append('username', state.email);
    formData.append('token', state.token);
    formData.append('edition', state.edition);
    const entities = selectedEntities();
    if (entities.length) formData.append('entityTypes', JSON.stringify(entities));
    const inc = (state.includeTerms || []).join('\n').trim();
    if (inc) formData.append('includeTerms', inc);
    const exc = (state.excludeTerms || []).join('\n').trim();
    if (exc) formData.append('excludeTerms', exc);
    if (state.mode === 'pseudonymiser' && state.pseudoConfig) {
      formData.append('processingMode', 'pseudonymiser');
      formData.append('pseudoStrategy', state.pseudoConfig.strategy || '');
      formData.append('pseudoScope', state.pseudoConfig.scope || '');
      formData.append('pseudoKeyMode', state.pseudoConfig.keyMode || '');
      formData.append('pseudoRestoreWindow', state.pseudoConfig.restoreWindow || '');
      formData.append('pseudoDeterministic', state.pseudoConfig.deterministic ? 'true' : 'false');
      formData.append('pseudoPreserveFormat', state.pseudoConfig.preserveFormat ? 'true' : 'false');
    }
    state.files.forEach((item) => formData.append('fileUpload[]', item.file, item.fileName));

    try {
      const response = await fetchWithTimeout(ANON_ENDPOINT, { method: 'POST', body: formData }, REQUEST_TIMEOUT);
      if (!response.ok) {
        const raw = await response.text();
        let msg = 'Erreur de traitement. Vérifiez puis réessayez.';
        try { const json = JSON.parse(raw); if (json && (json.userErrorMessage || json.errorMessage)) msg = json.userErrorMessage || json.errorMessage; }
        catch (e) { if (raw && raw.length < 220) msg = raw; }
        throw new Error(msg);
      }
      const contentDisposition = response.headers.get('Content-Disposition') || '';
      const blob = await response.blob();
      state.resultUrl = URL.createObjectURL(blob);
      state.resultFilename = parseFilename(contentDisposition);
      ui.download.href = state.resultUrl;
      ui.download.setAttribute('download', state.resultFilename);
      ui.download.classList.add('is-visible');
      setStatus('success', 'Traitement terminé. Téléchargez le résultat.');
    } catch (err) {
      if (err && err.name === 'AbortError') setStatus('error', 'Délai dépassé. Réessayez avec un lot plus petit.');
      else setStatus('error', (err && err.message) ? err.message : 'Erreur inattendue.');
    } finally {
      state.processing = false;
      updateActions();
    }
  }

  function resetFiles() {
    if (state.processing) return;
    state.files = [];
    revokeResultUrl();
    ui.download.href = '#';
    ui.download.removeAttribute('download');
    ui.download.classList.remove('is-visible');
    setStatus('', '');
    renderFileList();
  }

  async function processText() {
    const value = (ui.textInput.value || '').trim();
    if (!value) { setTextOutput('Ajoutez un texte à traiter.', false); ui.textOutput.classList.remove('agf-text-output--loading'); return; }
    if (lastProcessedText === value && lastProcessedResult !== null) {
      setTextOutput(lastProcessedResult, lastProcessedHasTags, lastProcessedHtml);
      ui.textOutput.classList.remove('agf-text-output--loading');
      return;
    }
    state.textProcessing = true;
    ui.textOutput.textContent = 'Traitement en cours...';
    ui.textOutput.classList.add('agf-text-output--loading');

    try { await ensureAuth(); } catch (e) { setTextOutput(e.message || 'Authentification indisponible.', false); state.textProcessing = false; ui.textOutput.classList.remove('agf-text-output--loading'); return; }

    const payload = new FormData();
    payload.append('username', state.email);
    payload.append('token', state.token);
    payload.append('edition', state.edition);
    payload.append('forceTextFormat', 'true');
    const entities = selectedEntities();
    if (entities.length) payload.append('entityTypes', JSON.stringify(entities));
    const inc = (state.includeTerms || []).join('\n').trim();
    if (inc) payload.append('includeTerms', inc);
    const exc = (state.excludeTerms || []).join('\n').trim();
    if (exc) payload.append('excludeTerms', exc);
    if (state.mode === 'pseudonymiser' && state.pseudoConfig) {
      payload.append('processingMode', 'pseudonymiser');
      payload.append('pseudoStrategy', state.pseudoConfig.strategy || '');
      payload.append('pseudoScope', state.pseudoConfig.scope || '');
      payload.append('pseudoKeyMode', state.pseudoConfig.keyMode || '');
      payload.append('pseudoRestoreWindow', state.pseudoConfig.restoreWindow || '');
      payload.append('pseudoDeterministic', state.pseudoConfig.deterministic ? 'true' : 'false');
      payload.append('pseudoPreserveFormat', state.pseudoConfig.preserveFormat ? 'true' : 'false');
    }
    payload.append('fileUpload1', new Blob([value], { type: 'text/plain;charset=utf-8' }), 'input.txt');

    try {
      const response = await fetchWithTimeout(ANON_TEXT_ENDPOINT, { method: 'POST', body: payload }, REQUEST_TIMEOUT);
      if (!response.ok) {
        const raw = await response.text();
        let msg = 'Erreur de traitement du texte.';
        try { const json = JSON.parse(raw); if (json && (json.userErrorMessage || json.errorMessage)) msg = json.userErrorMessage || json.errorMessage; }
        catch (err) { if (raw && raw.length < 220) msg = raw; }
        throw new Error(msg);
      }
      const blob = await response.blob();
      const raw = await blob.text();
      const out = applyStructuredResponse(raw);
      lastProcessedText = value;
      lastProcessedResult = out.plain;
      lastProcessedHasTags = out.useTags;
      lastProcessedHtml = out.html || null;
      setTextOutput(out.plain, out.useTags, lastProcessedHtml);
    } catch (err) {
      if (err && err.name === 'AbortError') setTextOutput('Délai dépassé. Réessayez avec un texte plus court.', false);
      else setTextOutput((err && err.message) ? err.message : 'Erreur inattendue.', false);
    } finally {
      state.textProcessing = false;
      ui.textOutput.classList.remove('agf-text-output--loading');
    }
  }

  function setTextOutput(plain, useTags, html) {
    if (useTags && html) ui.textOutput.innerHTML = html;
    else ui.textOutput.textContent = plain || 'Le texte traité apparaîtra ici';
    renderOutputStats(plain || '');
  }

  function scheduleDebouncedText() {
    if (debounceTextTimer) clearTimeout(debounceTextTimer);
    debounceTextTimer = setTimeout(() => {
      debounceTextTimer = null;
      if (state.textProcessing) return;
      processText();
    }, DEBOUNCE_TEXT_MS);
  }

  function escapeHtml(s) {
    const div = document.createElement('div');
    div.textContent = s;
    return div.innerHTML;
  }

  function buildOutputWithTags(processedText) {
    if (!processedText) return { plain: processedText || '', useTags: false };
    const escaped = escapeHtml(processedText);
    const re = new RegExp('\\[(' + ENTITY_TYPES_TAG.join('|') + ')\\]', 'g');
    const html = escaped.replace(re, (_, type) => '<span class="agf-tag agf-tag-' + type + '">' + type + '</span>');
    if (html === escaped) return { plain: processedText, useTags: false };
    return { plain: processedText, useTags: true, html };
  }

  function extractEntityStats(processedText) {
    const counts = {};
    if (!processedText) return counts;
    let match;
    while ((match = PLACEHOLDER_RE.exec(processedText)) !== null) {
      const code = match[1];
      counts[code] = (counts[code] || 0) + 1;
    }
    PLACEHOLDER_RE.lastIndex = 0;
    return counts;
  }

  function renderOutputStats(processedText) {
    if (!ui.outputSummary || !ui.outputEntities) return;

    const stats = extractEntityStats(processedText);
    const entries = Object.entries(stats).sort((a, b) => {
      if (b[1] !== a[1]) return b[1] - a[1];
      return a[0].localeCompare(b[0]);
    });
    const total = entries.reduce((sum, item) => sum + item[1], 0);

    ui.outputEntities.textContent = '';
    if (total === 0) {
      ui.outputSummary.textContent = 'Aucun champ anonymisé détecté.';
      if (ui.lastMaskInfo) ui.lastMaskInfo.textContent = 'Champs anonymisés (texte): 0';
      return;
    }

    ui.outputSummary.textContent = total + ' champ(s) anonymisé(s) détecté(s) sur le dernier traitement texte.';
    if (ui.lastMaskInfo) ui.lastMaskInfo.textContent = 'Champs anonymisés (texte): ' + total;

    entries.forEach((entry) => {
      const chip = document.createElement('span');
      chip.className = 'agf-output-entity-chip';
      chip.textContent = entry[0] + ': ' + entry[1];
      ui.outputEntities.appendChild(chip);
    });
  }

  function applyStructuredResponse(raw) {
    let plain = (raw && raw.trim()) ? raw : 'Aucun contenu retourné.';
    try {
      const data = JSON.parse(raw);
      if (data && typeof data.processedText === 'string') plain = data.processedText;
    } catch (e) {}
    const built = buildOutputWithTags(plain);
    return { plain, useTags: built.useTags, html: built.html };
  }

  function applyEditionLocks() {
    ui.openTypes.classList.remove('is-locked');
    ui.openInclusion.classList.remove('is-locked');
  }

  function bindEvents() {
    ui.form.addEventListener('submit', submitFiles);
    ui.reset.addEventListener('click', resetFiles);

    ui.tabs.forEach((tab) => tab.addEventListener('click', () => setActiveTab(tab.getAttribute('data-tab'))));

    ui.dropzone.addEventListener('click', () => ui.input.click());
    ui.dropzone.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); ui.input.click(); } });
    ui.dropzone.addEventListener('dragover', (e) => { e.preventDefault(); ui.dropzone.classList.add('is-dragover'); });
    ['dragleave', 'dragend'].forEach((evt) => ui.dropzone.addEventListener(evt, () => ui.dropzone.classList.remove('is-dragover')));
    ui.dropzone.addEventListener('drop', (e) => { e.preventDefault(); ui.dropzone.classList.remove('is-dragover'); if (e.dataTransfer && e.dataTransfer.files) addFiles(e.dataTransfer.files); });
    ui.input.addEventListener('change', (e) => { if (e.target.files) addFiles(e.target.files); ui.input.value = ''; });

    ui.textInput.addEventListener('input', scheduleDebouncedText);
    ui.textInput.addEventListener('keyup', scheduleDebouncedText);
    ui.textClear.addEventListener('click', () => { ui.textInput.value = ''; setTextOutput('Le texte traité apparaîtra ici', false); lastProcessedText = null; lastProcessedResult = null; lastProcessedHasTags = false; lastProcessedHtml = null; if (debounceTextTimer) { clearTimeout(debounceTextTimer); debounceTextTimer = null; } });
    if (ui.textCopy) ui.textCopy.addEventListener('click', () => { const t = lastProcessedResult != null ? lastProcessedResult : (ui.textOutput.innerText || '').trim(); if (t && t !== 'Le texte traité apparaîtra ici') { navigator.clipboard.writeText(t).then(() => { ui.textCopy.innerHTML = 'Copié\u00a0!'; setTimeout(() => { ui.textCopy.innerHTML = '<span class="agf-icon-copy" aria-hidden="true"></span>Copier'; }, 1200); }); } });

    ui.modeRadios.forEach((radio) => radio.addEventListener('change', () => { setMode(radio.value); }));

    ui.pseudoMode.addEventListener('click', () => openModal(ui.modals.pseudo));
    ui.pseudoSaved.addEventListener('click', () => openModal(ui.modals.pseudo));
    ui.openTypes.addEventListener('click', () => openModal(ui.modals.types));
    ui.openInclusion.addEventListener('click', () => openModal(ui.modals.inclusion));
    ui.upgradeRestore.addEventListener('click', () => openModal(ui.modals.pseudo));

    ui.modalTypesClose.addEventListener('click', () => closeModal(ui.modals.types));
    if (ui.modalPseudoClose) ui.modalPseudoClose.addEventListener('click', () => closeModal(ui.modals.pseudo));
    ui.modalIncClose.addEventListener('click', () => closeModal(ui.modals.inclusion));

    ui.defaultsTypes.addEventListener('click', () => {
      Array.from(document.querySelectorAll('#agfTypeGrid input[type="checkbox"][data-entity]')).forEach((chk) => {
        chk.checked = DEFAULT_ENTITIES.includes(chk.getAttribute('data-entity'));
      });
      renderTypeCount();
    });

    if (ui.detectAllTypes) ui.detectAllTypes.addEventListener('click', () => {
      Array.from(document.querySelectorAll('#agfTypeGrid input[type="checkbox"][data-entity]')).forEach((chk) => { chk.checked = true; });
      renderTypeCount();
    });

    if (ui.ignoreAllTypes) ui.ignoreAllTypes.addEventListener('click', () => {
      Array.from(document.querySelectorAll('#agfTypeGrid input[type="checkbox"][data-entity]')).forEach((chk) => { chk.checked = false; });
      renderTypeCount();
    });

    ui.saveTypes.addEventListener('click', () => {
      localStorage.setItem(STORAGE_TYPES, JSON.stringify(selectedVisualEntities()));
      renderTypeCount();
      closeModal(ui.modals.types);
    });

    if (ui.pseudoDefaults) ui.pseudoDefaults.addEventListener('click', () => {
      state.pseudoConfig = { ...DEFAULT_PSEUDO_CONFIG };
      applyPseudoToUi(state.pseudoConfig);
      renderPseudoSummary();
    });

    if (ui.savePseudo) ui.savePseudo.addEventListener('click', () => {
      state.pseudoConfig = readPseudoFromUi();
      localStorage.setItem(STORAGE_PSEUDO, JSON.stringify(state.pseudoConfig));
      setMode('pseudonymiser');
      setStatus('success', 'Politique de pseudonymisation enregistrée.');
      closeModal(ui.modals.pseudo);
    });

    if (ui.includeAdd) ui.includeAdd.addEventListener('click', () => {
      if (addTerm('include', ui.includeInput ? ui.includeInput.value : '')) {
        if (ui.includeInput) ui.includeInput.value = '';
        if (ui.includeInput) ui.includeInput.focus();
      }
    });

    if (ui.excludeAdd) ui.excludeAdd.addEventListener('click', () => {
      if (addTerm('exclude', ui.excludeInput ? ui.excludeInput.value : '')) {
        if (ui.excludeInput) ui.excludeInput.value = '';
        if (ui.excludeInput) ui.excludeInput.focus();
      }
    });

    if (ui.includeInput) ui.includeInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        if (addTerm('include', ui.includeInput.value)) ui.includeInput.value = '';
      }
    });

    if (ui.excludeInput) ui.excludeInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        if (addTerm('exclude', ui.excludeInput.value)) ui.excludeInput.value = '';
      }
    });

    if (ui.inclusionDefaults) ui.inclusionDefaults.addEventListener('click', () => {
      state.includeTerms = [];
      state.excludeTerms = [];
      syncHiddenTermFields();
      renderTermList('include');
      renderTermList('exclude');
      renderInclusionSummary();
    });

    ui.saveInclusion.addEventListener('click', () => {
      if (ui.includeInput && ui.includeInput.value) {
        addTerm('include', ui.includeInput.value);
        ui.includeInput.value = '';
      }
      if (ui.excludeInput && ui.excludeInput.value) {
        addTerm('exclude', ui.excludeInput.value);
        ui.excludeInput.value = '';
      }
      syncHiddenTermFields();
      localStorage.setItem(STORAGE_INC, (ui.includeTerms && ui.includeTerms.value) || '');
      localStorage.setItem(STORAGE_EXC, (ui.excludeTerms && ui.excludeTerms.value) || '');
      setStatus('success', "Listes d'inclusion/exclusion enregistrées.");
      closeModal(ui.modals.inclusion);
    });

    if (ui.manualAuthToggle && ui.manualAuth && ui.manualAuthFields) {
      ui.manualAuthToggle.addEventListener('click', () => {
        const collapsed = ui.manualAuth.classList.toggle('is-collapsed');
        ui.manualAuthFields.setAttribute('aria-hidden', collapsed ? 'true' : 'false');
        ui.manualAuthToggle.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
        ui.manualAuthToggle.textContent = collapsed ? 'Utiliser des identifiants manuels' : 'Masquer les identifiants manuels';
      });
    }

    document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeAllModals(); });

    Object.keys(ui.modals).forEach((key) => {
      const overlay = ui.modals[key];
      overlay.addEventListener('click', (e) => { if (e.target === overlay) closeModal(overlay); });
    });

    Array.from(document.querySelectorAll('#agfTypeGrid input[type="checkbox"][data-entity]')).forEach((chk) => chk.addEventListener('change', renderTypeCount));
  }

  async function init() {
    await waitForMemberstack(10000, 200);
    state.edition = await detectEdition();
    const editionFromUrl = new URLSearchParams(window.location.search).get('edition');
    if (editionFromUrl) {
      const n = editionFromUrl.toLowerCase();
      if (['free', 'pro', 'ent', 'business', 'anonymisation'].includes(n)) state.edition = n === 'business' ? 'ent' : n;
    }
    localStorage.setItem('agilo:edition', state.edition);
    if (ui.manualEdition) ui.manualEdition.value = state.edition;

    state.email = await getUserEmail();
    if (state.email && !getManualAuth()) await getToken(state.email, state.edition, 0).catch(() => {});

    bindEvents();
    setActiveTab('file');
    loadPreferences();
    applyEditionLocks();
    renderFileList();
    updateActions();
    runSessionMaintenance();
    loadApiVersion();
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init);
  else init();
})();
</script>

</body>
</html>

